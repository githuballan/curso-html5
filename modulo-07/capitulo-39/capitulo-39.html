<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Tudo que você precisa aprender sobre grid layout no CSS">
    <title>High order function</title>
    <link rel="stylesheet" href="../../style.css">
    <link rel="shortcut icon" href="../../imagens/Study.ico"type="image/x-icon">
    <script src="script.js"></script>
    <a class="buttom buttom-index" href="../../index.html">Índice</a>
</head>
<body>
    <header>
        <h1>Programação funcional </h1>
        <h1>High order function</h1>

    </header>
    <nav>

    </nav>
    <main>
        <section id="introducao">
            <h2>Introdução à Programação Funcional</h2>
            <p>A programação funcional é um paradigma de programação que trata a computação como a avaliação de funções matemáticas e evita estados e dados mutáveis. Ela enfatiza a aplicação de funções, em contraste com a programação imperativa, que enfatiza mudanças no estado do programa.</p>
            <p>Algumas características importantes da programação funcional incluem:</p>
            <ul>
                <li>Funções de primeira classe e de ordem superior</li>
                <li>Imutabilidade</li>
                <li>Funções puras</li>
                <li>Recursão</li>
                <li>Expressões lambda</li>
            </ul>
        </section><!--introducao-->
        <article id="high-order-function">
            <h2>High Order Function</h2>
            <section id="int-hof">
                <p>Neste capítulo, vamos falar sobre High Order Functions (Funções de Alta Ordem) na programação funcional. High Order Functions são funções que podem receber outras funções como argumentos ou retornar funções como resultado.</p>
                <p>As três High Order Functions mais comuns são:</p>
                <ul>
                    <li><strong>filter</strong>: Cria um novo array com todos os elementos que passam em um teste especificado por uma função.</li>
                        <li><strong>map</strong>: Aplica uma função a cada elemento de um array e retorna um novo array com os resultados.</li>
                    <li><strong>reduce</strong>: Aplica uma função a um acumulador e a cada elemento de um array (da esquerda para a direita) para reduzi-lo a um único valor.</li>
                </ul>
                <p>Essas funções são muito úteis para manipular e transformar arrays de maneira concisa e expressiva.</p>
                
            </section><!-- /#int-hof -->
            <article id="filter">
                <h3>Filter</h3>
                <p>A função <code>filter</code> é uma das High Order Functions mais utilizadas na programação funcional. Ela permite criar um novo array contendo apenas os elementos que passam em um teste especificado por uma função fornecida.</p>
                <p>O <code>filter</code> não modifica o array original, mas retorna um novo array com os elementos que satisfazem a condição.</p>
                <p>A sintaxe da função <code>filter</code> é a seguinte:</p>
                
            <code>const newArray = arrayOriginal.filter(callback(element[, index[, array]])[, thisArg]);</code>
                    
                </div>
                <p><strong>Exemplo de uso do filter</strong></p>
                <div class="pre">
                    <pre>
            const numeros = [1, 2, 3, 4, 5, 6];
            const <abbr title="Novo array">numerosPares</abbr> = <abbr title="Array que será testado">numeros</abbr>.filter(<abbr title="variável que receberá os elementos do array que será testado">numero</abbr> => <abbr title="teste que deverá gerar um valor booleano">numero % 2 === 0</abbr>);
            console.log(numerosPares); // [2, 4, 6]
                    </pre>
                </div>
                <p>No exemplo acima, a função <code>filter</code> é usada para criar um novo array <code>numerosPares</code> que contém apenas os números pares do array original <code>numeros</code>.</p>
                <p>A função de callback <code>numero => numero % 2 === 0</code> verifica se um número é par (ou seja, se o resto da divisão por 2 é igual a zero).</p>
                <p>A função <code>filter</code> exige que a função de callback retorne valores booleanos. Se o elemento do <code>arrayOriginal</code> passar no teste e o resultado for <code>true</code>, ele será incluído no novo array, neste caso, <code>numerosPares</code>.</p>

            </article><!-- /#filter -->
            <article id="Map">
                <h3>Map</h3>
                <p>A função <code>map</code> é outra High Order Function muito utilizada na programação funcional. Ela permite aplicar uma função a cada elemento de um array e retornar um novo array com os resultados.</p>
                <p>O <code>map</code> não modifica o array original, assim como filter, mas retorna um novo array com os elementos transformados pela função fornecida.</p>
                <p>A sintaxe da função <code>map</code> é a seguinte:</p>
               <code>
            const newArray = arrayOriginal.map(callback(element[, index[, array]])[, thisArg]);
               </code>
                <p><strong>Exemplo de uso do map</strong></p>
                <div class="pre">
                    <pre>
const numeros = [1, 2, 3, 4, 5];

function dobrarNumero(numero) {
    return numero * 2;
}

const numerosDobrados = numeros.map(dobrarNumero);
console.log(numerosDobrados); // [2, 4, 6, 8, 10]
                    </pre>
                </div>
                <p>No exemplo acima, a função <code>map</code> é usada para criar um novo array <code>numerosDobrados</code> que contém os números do array original <code>numeros</code> multiplicados por 2.</p>
                <p>A função de callback <code>numero => numero * 2</code> multiplica cada número por 2 e retorna o resultado.</p>
                <p>A função <code>map</code> aplica a função de callback a cada elemento do <code>arrayOriginal</code> e retorna um novo array com os resultados.</p>

                <strong><p>Veja outro exmplo:</p></strong>
                <div class="pre">
                    <pre>
function novoAluno(nome, nota) {
    return { nome, nota };
};

let alunos = [
    novoAluno('Mario', 10),
    novoAluno('José', 5),
    novoAluno('Maria', 9),
    novoAluno('João', 6),
    novoAluno('Pedro', 3),
];
let pontinhoExtra = alunos.map(aluno => ({
    nome: aluno.nome,
    nota: aluno.nota + 1
}));
console.log(pontinhoExtra);

console.log(alunos);
                </pre>
                </div>
                <p>No exemplo acima, a função <code>map</code> é usada para criar um novo array <code>pontinhoExtra</code> que contém os alunos do array original <code>alunos</code> com uma nota extra.</p>
                <p>A função de callback <code>aluno => ({ nome: aluno.nome, nota: aluno.nota + 1 })</code> retorna um objeto com o nome e a nota do aluno, sendo que a nota é incrementada em 1.</p>
                <p>A função <code>map</code> aplica a função de callback a cada elemento do <code>arrayOriginal</code> e retorna um novo array com os resultados.</p>
                <section id="erro-comum">
                    <h3>Erro Comum ao Usar Map</h3>
                    <p>Um erro comum ao usar a função <code>map</code> é modificar o array original sem querer. Isso pode acontecer quando os elementos do array são objetos e a função de callback modifica esses objetos diretamente.</p>
                    <p>Veja o exemplo abaixo:</p>
                    <div class="pre">
                        <pre>
let alunos = [
    { nome: 'Mario', nota: 10 },
    { nome: 'José', nota: 5 },
    { nome: 'Maria', nota: 9 },
    { nome: 'João', nota: 6 },
    { nome: 'Pedro', nota: 3 },
];

let pontinhoExtra = alunos.map(aluno => {
    aluno.nota += 1;
    return aluno;
});

console.log(pontinhoExtra);
console.log(alunos);
                        </pre>
                    </div>
                    <p>No exemplo acima, a função <code>map</code> é usada para criar um novo array <code>pontinhoExtra</code> que contém os alunos do array original <code>alunos</code> com uma nota extra. No entanto, a função de callback modifica diretamente a propriedade <code>nota</code> dos objetos do array original.</p>
                    <p>Como resultado, tanto o array <code>pontinhoExtra</code> quanto o array original <code>alunos</code> são modificados, pois ambos referenciam os mesmos objetos.</p>
                    <p>Para evitar esse problema, é importante criar novos objetos dentro da função de callback, em vez de modificar os objetos existentes. Veja a correção abaixo:</p>
                    <div class="pre">
                        <pre>
let alunos = [
    { nome: 'Mario', nota: 10 },
    { nome: 'José', nota: 5 },
    { nome: 'Maria', nota: 9 },
    { nome: 'João', nota: 6 },
    { nome: 'Pedro', nota: 3 },
];

let pontinhoExtra = alunos.map(aluno => ({
    <abbr title="O detalhe que faltou">nome:</abbr> aluno.nome,
    <abbr title="O detalhe que faltou">nota:</abbr> aluno.nota + 1
}));

console.log(pontinhoExtra);
console.log(alunos);
                        </pre>
                    </div>
                    <p>Na correção acima, a função de callback retorna novos objetos com as propriedades <code>nome</code> e <code>nota</code> incrementada em 1, sem modificar os objetos do array original.</p>
                </section>





            </article><!--Map-->
            <article id="reduce">
                <h3>Reduce</h3>
                <p>A função <code>reduce</code> é uma das High Order Functions mais poderosas e versáteis na programação funcional. Ela permite reduzir um array a um único valor, aplicando uma função a um acumulador e a cada elemento do array (da esquerda para a direita).</p>
                <p>O <code>reduce</code> não modifica o array original, mas retorna um único valor que é o resultado da redução.</p>
                <p>A sintaxe da função <code>reduce</code> é a seguinte:</p>
                <code>
                    const resultado = arrayOriginal.reduce(callback(acumulador, valorAtual[, index[, array]])[, valorInicial]);
                </code>
                <p><strong>Exemplo de uso do reduce</strong></p>
                <div class="pre">
                    <pre>
            const numeros = [1, 2, 3, 4, 5];

            function somaNumeros(acumulador, numero) {
                return acumulador + numero;
            }
            const soma = numeros.reduce(somaNumeros, 0);
            console.log(soma); // 15
                    </pre>
                </div>
                <p>No exemplo acima, a função <code>reduce</code> é usada para somar todos os números do array <code>numeros</code>. A função de callback <code>function(acumulador, numero) { return acumulador + numero; }</code> adiciona cada número ao acumulador, e o valor inicial do acumulador é 0.</p>
                <p>A função <code>reduce</code> aplica a função de callback a cada elemento do <code>arrayOriginal</code> e retorna o valor final do acumulador.</p>
                <p><strong>Outro exemplo de uso do reduce</strong></p>
                <div class="pre">
                    <pre>
            const alunos = [
                { nome: 'Mario', nota: 10 },
                { nome: 'José', nota: 5 },
                { nome: 'Maria', nota: 9 },
                { nome: 'João', nota: 6 },
                { nome: 'Pedro', nota: 3 },
            ];

            function calcularMedia(acumulador, aluno, index, array) {
                acumulador += aluno.nota;
                if (index === array.length - 1) {
                    return acumulador / array.length;
                }
                return acumulador;
            }

            const media = alunos.reduce(calcularMedia, 0);

            console.log(media); // 6.6
                    </pre>
                </div>
                <p>No exemplo acima, a função <code>reduce</code> é usada para calcular a média das notas dos alunos. A função de callback adiciona a nota de cada aluno ao acumulador e, se for o último elemento do array, divide o acumulador pelo número total de alunos para obter a média.</p>
                <p>A função <code>reduce</code> é muito útil para realizar operações acumulativas em arrays, como somar valores, calcular médias, encontrar máximos e mínimos, entre outras.</p>
            </article><!-- /#reduce -->
        </article><!-- /#high-order-function -->
        <article id="fetch">
            <h2>Fetch API</h2>
            <p>A Fetch API é uma interface moderna que permite fazer requisições HTTP de forma simples e intuitiva. Ela é usada para buscar recursos na web, como dados de uma API, e funciona de maneira assíncrona, permitindo que o código continue sendo executado enquanto a requisição é processada.</p>
            <p>A Fetch API substitui a antiga interface <code>XMLHttpRequest</code> e oferece uma maneira mais poderosa e flexível de fazer requisições HTTP.</p>
            <aside>
                
                <p>API (Interface de Programação de Aplicações) é um conjunto de definições e protocolos que permitem a comunicação entre diferentes sistemas de software. As APIs são usadas para integrar diferentes serviços e permitir que eles troquem dados entre si.</p>
            </aside>
            <p>A sintaxe básica para usar a Fetch API é a seguinte:</p>
            <code>
                fetch(url, options)
                    .then(response => response.json())
                    .then(data => console.log(data))
                    .catch(error => console.error('Erro:', error));
            </code>
            <p>Vamos detalhar cada parte dessa sintaxe:</p>
            <ul>
                <li><code>fetch(url, options)</code>: Faz uma requisição HTTP para a URL especificada. O parâmetro <code>options</code> é opcional e pode ser usado para configurar a requisição, como o método HTTP (GET, POST, etc.), cabeçalhos, corpo da requisição, entre outros.</li>
                <li><code>.then(response => response.json())</code>: O método <code>then</code> é usado para processar a resposta da requisição. A resposta é convertida para JSON usando o método <code>json()</code>.</li>
                <li><code>.then(data => console.log(data))</code>: O método <code>then</code> é usado novamente para processar os dados convertidos em JSON. Neste exemplo, os dados são exibidos no console.</li>
                <li><code>.catch(error => console.error('Erro:', error))</code>: O método <code>catch</code> é usado para capturar e tratar erros que possam ocorrer durante a requisição.</li>
            </ul>
            <p><strong>Exemplo de uso da Fetch API</strong></p>
            <div class="pre">
                <pre>
        fetch('https://jsonplaceholder.typicode.com/posts')
            .then(response => response.json())
            .then(data => {
                console.log('Dados recebidos:', data);
                // Processar os dados recebidos
            })
            .catch(error => {
                console.error('Erro ao buscar os dados:', error);
            });
                </pre>
            </div>
            <p>No exemplo acima, a Fetch API é usada para fazer uma requisição GET para a URL <code>https://jsonplaceholder.typicode.com/posts</code>. A resposta é convertida para JSON e os dados são exibidos no console. Se ocorrer um erro durante a requisição, ele será capturado e exibido no console.</p>
            <p>A Fetch API também pode ser usada para fazer requisições POST, enviar dados no corpo da requisição e configurar cabeçalhos. Veja o exemplo abaixo:</p>
            <div class="pre">
                <pre>
        fetch('https://jsonplaceholder.typicode.com/posts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                title: 'foo',
                body: 'bar',
                userId: 1
            })
        })
            .then(response => response.json())
            .then(data => {
                console.log('Dados enviados:', data);
                // Processar a resposta
            })
            .catch(error => {
                console.error('Erro ao enviar os dados:', error);
            });
                </pre>
            </div>
            <p>No exemplo acima, a Fetch API é usada para fazer uma requisição POST para a URL <code>https://jsonplaceholder.typicode.com/posts</code>. Os dados são enviados no corpo da requisição em formato JSON. A resposta é convertida para JSON e exibida no console. Se ocorrer um erro durante a requisição, ele será capturado e exibido no console.</p>
        </article> <!-- /#fetch -->    
       
    <footer>
<script src="script.js"></script>
    </footer>
</body>
</html>